function gcodeLines = generateLineGcode(pointsXYZ, orientation, ePerMM, feedrate, layerHeight, zHop, outFile)
%GENERATELINEGCODE  Generate G-code for horizontal or vertical lines through points.
%
%   gcodeLines = generateLineGcode(pointsXYZ, orientation, ePerMM, feedrate, layerHeight, zHop)
%   gcodeLines = generateLineGcode(pointsXYZ, orientation, ePerMM, feedrate, layerHeight, zHop, outFile)
%
%   INPUTS
%     pointsXYZ   : N×3 matrix of [X Y Z] points in **meters**
%     orientation : 'horizontal' or 'vertical'
%                   - 'horizontal'  => constant Y, lines along X (rows)
%                   - 'vertical'    => constant X, lines along Y (columns)
%     ePerMM      : extrusion per mm of movement (mm filament / mm travel)
%     feedrate    : feed rate (F) in mm/min
%     layerHeight : desired layer height in Z (mm) – used to fill between slices
%     zHop        : Z hop height in mm used on G0 travels (can be 0)
%     outFile     : (optional) filename to write G-code to. If empty/omitted,
%                   no file is written.
%
%   OUTPUT
%     gcodeLines  : cell array of strings, each a G-code line.

    arguments
        pointsXYZ (:,3) double
        orientation (1,:) char
        ePerMM (1,1) double {mustBeNonnegative}
        feedrate (1,1) double {mustBePositive}
        layerHeight (1,1) double {mustBePositive}
        zHop (1,1) double {mustBeNonnegative}
        outFile (1,:) char = ''
    end

    % ---- Convert input coordinates from meters to millimeters ----
    pointsMM = pointsXYZ * 1000;   % now in mm

    % Remove rows with NaNs (if any)
    pointsMM = pointsMM(all(~isnan(pointsMM),2), :);

    if isempty(pointsMM)
        warning('No points provided. Returning empty G-code.');
        gcodeLines = {};
        return;
    end

    % ---- Normalize orientation ----
    orientation = lower(strtrim(orientation));
    if any(strcmp(orientation, ["h","x"]))
        orientation = 'horizontal';
    elseif any(strcmp(orientation, ["v","y"]))
        orientation = 'vertical';
    elseif ~any(strcmp(orientation, ["horizontal","vertical"]))
        error('orientation must be ''horizontal'' or ''vertical''.');
    end

    gcodeLines = {};
    
    % ---- Header: absolute XYZ, relative extrusion ----
    gcodeLines{end+1} = '; Generated by generateLineGcode';
    gcodeLines{end+1} = 'G21 ; units in mm';
    gcodeLines{end+1} = 'G90 ; absolute positioning (X/Y/Z)';
    gcodeLines{end+1} = 'M83 ; relative extrusion (E)';
    gcodeLines{end+1} = 'G92 E0 ; reset extrusion';

    % ---- Find discrete original Z "slices" (from your data) ----
    zRounded = round(pointsMM(:,3), 4);          % original Z in mm (rounded)
    zLevels  = unique(zRounded, 'sorted');       % sorted unique Z levels

    if numel(zLevels) == 1
        zStartList = zLevels(1);
        zEndList   = zLevels(1);
    else
        zStartList = zLevels(1:end-1);
        zEndList   = zLevels(2:end);
    end

    % Tolerance for grouping X/Y as same line (mm)
    xyRoundTol = 4;  % decimal places

    % ---- Loop over each slice [zStart, zEnd] ----
    for si = 1:numel(zStartList)
        z0 = zStartList(si);    % lower Z of slice
        z1 = zEndList(si);      % upper Z of slice

        % Points that belong exactly to this lower Z level (XY pattern)
        maskLayer = (zRounded == z0);
        ptsLayer  = pointsMM(maskLayer, :);

        if size(ptsLayer,1) < 2
            continue;
        end

        % ---- Build XY lines for this slice in a logical scan order ----
        lineGroups = {};   % each cell: N_i x 2 [X Y]

        if strcmp(orientation, 'horizontal')
            % Horizontal lines: constant Y, varying X
            % Group by Y, sorted bottom→top (ascending Y).
            keyY = round(ptsLayer(:,2), xyRoundTol);
            [groupYs, ~, groupIdx] = unique(keyY);   % groupYs sorted asc

            for gi = 1:numel(groupYs)
                maskG   = (groupIdx == gi);
                ptsLine = ptsLayer(maskG, :);
                if size(ptsLine,1) < 2, continue; end

                % Sort along X so each row is printed left→right.
                [~, ord] = sort(ptsLine(:,1));       % X ascending
                ptsLine  = ptsLine(ord, :);

                lineGroups{end+1} = ptsLine(:, 1:2); %#ok<AGROW>
            end

        else
            % Vertical lines: constant X, varying Y
            % Group by X, sorted left→right (ascending X).
            keyX = round(ptsLayer(:,1), xyRoundTol);
            [groupXs, ~, groupIdx] = unique(keyX);   % groupXs sorted asc

            for gi = 1:numel(groupXs)
                maskG   = (groupIdx == gi);
                ptsLine = ptsLayer(maskG, :);
                if size(ptsLine,1) < 2, continue; end

                % Sort along Y so each column is printed bottom→top.
                [~, ord] = sort(ptsLine(:,2));       % Y ascending
                ptsLine  = ptsLine(ord, :);

                lineGroups{end+1} = ptsLine(:, 1:2); %#ok<AGROW>
            end
        end

        if isempty(lineGroups)
            continue;
        end

        % ---- Fill this slice with layers at 'layerHeight' ----
        if z1 < z0
            tmp = z0; z0 = z1; z1 = tmp;
        end

        zLayers = z0 : layerHeight : z1;
        if isempty(zLayers)
            zLayers = z0;
        end

        % Loop over layers within this slice
        for li = 1:numel(zLayers)
            zPrint = zLayers(li);

            % ---- Serpentine ordering of lines per layer ----
            nLines = numel(lineGroups);
            if mod(li-1, 2) == 0
                % Even index (li = 1,3,5,...) -> normal order: left→right / bottom→top
                lineOrder = 1:nLines;
            else
                % Odd index (li = 2,4,6,...) -> reverse order: right→left / top→bottom
                lineOrder = nLines:-1:1;
            end

            for idxL = lineOrder
                xy = lineGroups{idxL};      % N x 2 [X Y], ordered along the line

                % ---- Z-HOP + travel to line start (no extrusion) ----
                p0 = xy(1,:);             % [Xstart, Ystart]

                if zHop > 0
                    % Hop up
                    gcodeLines{end+1} = sprintf('G0 Z%.3f F%.1f', ...
                                                zPrint + zHop, feedrate);
                    % Travel in XY at hopped Z
                    gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                                                p0(1), p0(2), zPrint + zHop, feedrate);
                    % Drop back to print Z
                    gcodeLines{end+1} = sprintf('G0 Z%.3f F%.1f', ...
                                                zPrint, feedrate);
                else
                    % No hop: direct travel at print Z
                    gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                                                p0(1), p0(2), zPrint, feedrate);
                end

                % ---- Extruding moves along the line ----
                for k = 2:size(xy,1)
                    pPrev = xy(k-1,:);
                    pCurr = xy(k,:);

                    dx = pCurr(1) - pPrev(1);
                    dy = pCurr(2) - pPrev(2);
                    segLen = hypot(dx, dy);    % XY distance in mm

                    if segLen < 1e-6
                        % Same point -> skip
                        continue;
                    end

                    eSeg = ePerMM * segLen;    % relative extrusion for this move

                    gcodeLines{end+1} = sprintf( ...
                        'G1 X%.3f Y%.3f Z%.3f E%.5f F%.1f', ...
                        pCurr(1), pCurr(2), zPrint, eSeg, feedrate);
                end
            end
        end
    end

    % ---- Write to file if requested ----
    if ~isempty(outFile)
        fid = fopen(outFile, 'w');
        if fid == -1
            error('Could not open file "%s" for writing.', outFile);
        end
        for i = 1:numel(gcodeLines)
            fprintf(fid, '%s\n', gcodeLines{i});
        end
        fclose(fid);
    end
end
