function gcodeLines = generateLineGcode3DMapping(pointsXYZ, orientation, ePerMM, feedrate, layerHeight, zHop, outFile)
%GENERATELINEGCODE Generate SAFE ZigZag G-code that never leaves the point cloud.

    arguments
        pointsXYZ (:,3) double
        orientation (1,:) char
        ePerMM (1,1) double {mustBeNonnegative}
        feedrate (1,1) double {mustBePositive}
        layerHeight (1,1) double {mustBePositive}
        zHop (1,1) double {mustBeNonnegative}
        outFile (1,:) char = ''
    end

    % 1. Cleanup and Conversion
    pointsMM = pointsXYZ * 1000; 
    pointsMM = pointsMM(all(~isnan(pointsMM),2), :);
    
    if isempty(pointsMM)
        gcodeLines = {}; warning('No points.'); return;
    end

    % ---- FIXED ORIENTATION CHECK ----
    orientation = lower(strtrim(orientation));
    if any(strcmp(orientation, ["h", "x", "horizontal"]))
        orientation = 'horizontal';
    elseif any(strcmp(orientation, ["v", "y", "vertical"]))
        orientation = 'vertical';
    else
        error('Invalid orientation. Use ''horizontal'' or ''vertical''.'); 
    end
    % ---------------------------------

    gcodeLines = {};
    gcodeLines{end+1} = '; Generated by Safe-ZigZag Logic';
    gcodeLines{end+1} = 'G21 ; mm';
    gcodeLines{end+1} = 'G90 ; absolute';
    gcodeLines{end+1} = 'M83 ; relative E';
    gcodeLines{end+1} = 'G92 E0';

    % 2. Build Connectivity Graph (The "Map")
    zRounded = round(pointsMM(:,3), 3);
    zLevels  = unique(zRounded, 'sorted');
    
    for zi = 1:numel(zLevels)
        zCurrent = zLevels(zi);
        maskZ = (zRounded == zCurrent);
        ptsSlice = pointsMM(maskZ, :);
        
        if size(ptsSlice, 1) < 2, continue; end

        % -- A. Build Adjacency Graph --
        sampleSz = min(500, size(ptsSlice,1));
        dists = pdist(ptsSlice(1:sampleSz, 1:2)); 
        minDist = min(dists(dists > 0));
        if isempty(minDist), minDist = 1; end
        
        connectDist = minDist * 1.5; 
        
        try
            idxs = rangesearch(ptsSlice(:,1:2), ptsSlice(:,1:2), connectDist);
            sources = []; targets = [];
            for i = 1:numel(idxs)
                nbors = idxs{i};
                nbors = nbors(nbors > i); 
                if ~isempty(nbors)
                    sources = [sources; repmat(i, numel(nbors), 1)]; %#ok<AGROW>
                    targets = [targets; nbors']; %#ok<AGROW>
                end
            end
            G = graph(sources, targets, [], size(ptsSlice,1));
        catch
            D = squareform(pdist(ptsSlice(:,1:2)));
            Adj = (D <= connectDist) & (D > 0);
            G = graph(Adj);
        end
        
        % -- B. Plan Raster Lines --
        linesXY = {}; 
        xyTol = minDist * 0.1; 
        
        if strcmp(orientation, 'horizontal')
            Y = ptsSlice(:,2);
            [uY, ~, ~] = unique(round(Y, 3));
            for ui = 1:numel(uY)
                thisY = uY(ui);
                maskY = abs(Y - thisY) < xyTol;
                rowPts = ptsSlice(maskY, :);
                [~, sortX] = sort(rowPts(:,1));
                rowPts = rowPts(sortX, :);
                
                if size(rowPts,1) > 1
                    dx = diff(rowPts(:,1));
                    breaks = [0; find(dx > connectDist); size(rowPts,1)];
                else
                    breaks = [0; 1];
                end
                
                for b = 1:numel(breaks)-1
                    seg = rowPts(breaks(b)+1 : breaks(b+1), :);
                    if mod(ui, 2) == 0, seg = flipud(seg); end
                    linesXY{end+1} = seg; %#ok<AGROW>
                end
            end
        else
            X = ptsSlice(:,1);
            [uX, ~, ~] = unique(round(X, 3));
            for ui = 1:numel(uX)
                thisX = uX(ui);
                maskX = abs(X - thisX) < xyTol;
                colPts = ptsSlice(maskX, :);
                [~, sortY] = sort(colPts(:,2));
                colPts = colPts(sortY, :);
                
                if size(colPts,1) > 1
                    dy = diff(colPts(:,2));
                    breaks = [0; find(dy > connectDist); size(colPts,1)];
                else
                    breaks = [0; 1];
                end
                
                for b = 1:numel(breaks)-1
                    seg = colPts(breaks(b)+1 : breaks(b+1), :);
                    if mod(ui, 2) == 0, seg = flipud(seg); end
                    linesXY{end+1} = seg; %#ok<AGROW>
                end
            end
        end
        
        % -- C. Generate Moves --
        ptsSliceRounded = round(ptsSlice, 4);
        findNode = @(pt) find(ismember(ptsSliceRounded, round(pt,4), 'rows'), 1);
        lastNode = [];
        
        for li = 1:numel(linesXY)
            thisLine = linesXY{li}; 
            startPt = thisLine(1,:);
            endPt   = thisLine(end,:);
            startNode = findNode(startPt);
            
            % 1. Travel
            if isempty(lastNode)
                gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                    startPt(1), startPt(2), startPt(3), feedrate);
            else
                [pathNodes, pathDist] = shortestpath(G, lastNode, startNode);
                if pathDist <= 1.01 
                    gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                        startPt(1), startPt(2), startPt(3), feedrate);
                elseif isempty(pathNodes)
                    warning('Disconnected island at %.3f,%.3f.', startPt(1), startPt(2));
                    gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                        startPt(1), startPt(2), startPt(3), feedrate);
                else
                    for pi = 2:numel(pathNodes)
                        pIdx = pathNodes(pi);
                        pCoord = ptsSlice(pIdx, :);
                        gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f F%.1f', ...
                            pCoord(1), pCoord(2), pCoord(3), feedrate);
                    end
                end
            end
            
            % 2. Extrude (G0)
            for k = 2:size(thisLine, 1)
                pPrev = thisLine(k-1,:);
                pCurr = thisLine(k,:);
                dist = norm(pCurr - pPrev);
                if dist < 1e-5, continue; end
                eAmt = dist * ePerMM;
                gcodeLines{end+1} = sprintf('G0 X%.3f Y%.3f Z%.3f E%.5f F%.1f', ...
                    pCurr(1), pCurr(2), pCurr(3), eAmt, feedrate);
            end
            lastNode = findNode(endPt);
        end
    end

    if ~isempty(outFile)
        fid = fopen(outFile, 'w');
        if fid == -1, error('Cannot open file'); end
        fprintf(fid, '%s\n', gcodeLines{:});
        fclose(fid);
    end
end